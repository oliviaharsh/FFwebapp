/*************** FluxFilm Backend — Fulfillment (FULL FILE) ***************/

/**
 * Fulfillment rules:
 * - If already FULFILLED -> return credentials again (from SUBSCRIPTIONS)
 * - If MANUAL_PENDING -> return postPaymentMessage (no credentials)
 * - Else require Status=PAID
 * - MANUAL plans -> create MANUAL task + create SUB row (no credentials yet)
 * - INSTANT plans:
 *    - Netflix:
 *        - Sharing plan -> allocate SAME reserved profile (P1) with CAPACITY (MaxTotal)
 *        - Private plan -> allocate rotating profile (P2+) 1-to-1 with cooldown
 *    - Prime:
 *        - Capacity allocation by device type (TV/NON_TV)
 *    - Account allocation:
 *        - whole account
 */

function fulfillOrder(orderId) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  try {
    const orders = sh_(TAB_ORDERS);
    const rowNum = getRowByValue_(orders, "OrderID", orderId);
    if (!rowNum) return bad_("Order not found.");

    const { idx } = headerIndex_(orders);

    // ---- Read current order state ----
    const status = String(orders.getRange(rowNum, idx["Status"] + 1).getValue() || "")
      .trim()
      .toUpperCase();

    const fulfillStatus = String(orders.getRange(rowNum, idx["FulfillmentStatus"] + 1).getValue() || "")
      .trim()
      .toUpperCase();

    const service = String(orders.getRange(rowNum, idx["Service"] + 1).getValue() || "").trim();
    const plan = String(orders.getRange(rowNum, idx["Plan"] + 1).getValue() || "").trim();
    const durationDays = asNumber_(orders.getRange(rowNum, idx["DurationDays"] + 1).getValue());

    const email = String(orders.getRange(rowNum, idx["Email"] + 1).getValue() || "").trim();
    const phone = String(orders.getRange(rowNum, idx["Phone"] + 1).getValue() || "").trim();
    const notes = String(orders.getRange(rowNum, idx["Notes"] + 1).getValue() || "").trim();
    const extraKey = String(orders.getRange(rowNum, idx["ExtraFieldKey"] + 1).getValue() || "").trim();
    const extraVal = String(orders.getRange(rowNum, idx["ExtraFieldValue"] + 1).getValue() || "").trim();

    // Read plan config (from PLANS)
    const planCfg = getPlanCfg_(service, plan);
    if (!planCfg) throw new Error("Plan config missing.");

    /**
     * ✅ CRITICAL FIX #1:
     * Handle "already fulfilled/manual" BEFORE blocking on Status != PAID.
     * So verify-again always returns credentials.
     */
    if (fulfillStatus === FULFILL_STATUS.FULFILLED) {
      const access = getAccessFromSubsByOrderId_(orderId) || {};
      sendOrderEmailsOnce_(orderId, "FULFILLED");
      return ok_({
        found: true,
        orderId,
        fulfillment: "FULFILLED",
        message: "✅ Already fulfilled. Showing credentials again.",
        postPaymentMessage: planCfg.postPaymentMessage || "",   // ✅ ADDED
        access
      });
    }

    if (fulfillStatus === FULFILL_STATUS.MANUAL_PENDING) {
      sendOrderEmailsOnce_(orderId, "MANUAL_PENDING");
      return ok_({
        found: true,
        orderId,
        fulfillment: "MANUAL_PENDING",
        message: planCfg.postPaymentMessage || "✅ Payment received. Activation will be done manually soon.",
        postPaymentMessage: planCfg.postPaymentMessage || ""    // ✅ ADDED
      });
    }

    /**
     * ✅ CRITICAL FIX #2:
     * If not already fulfilled/manual, then enforce PAID.
     */
    if (status !== ORDER_STATUS.PAID) return bad_("Payment not verified yet.");

    // Manual fulfillment (YouTube etc.)
    if (planCfg.fulfillmentMode === "MANUAL" || planCfg.allocationPolicy === "NONE") {
      const taskId = "TASK-" + Date.now().toString().slice(-7);
      sh_(TAB_MANUAL).appendRow([
        taskId,
        orderId,
        now_(),
        service,
        "MANUAL_ACTIVATION",
        "NORMAL",
        "PENDING",
        email,
        phone,
        extraKey,
        extraVal,
        notes,
        "",
        "",
      ]);

      orders.getRange(rowNum, idx["FulfillmentStatus"] + 1).setValue(FULFILL_STATUS.MANUAL_PENDING);
      if (idx["FulfilledAt"] != null) orders.getRange(rowNum, idx["FulfilledAt"] + 1).setValue(now_());

      // Create subscription record (no creds yet)
      const sub = createSubscriptionRecord_(orderId, service, plan, email, phone, durationDays, planCfg, {
        inventoryRef: "",
        deviceType: "",
        deviceConcurrency: "",
        access: {}
      });

      if (typeof notifyTelegram_ === "function") {
        notifyTelegram_("FULFILLMENT_MANUAL", { orderId, service, plan, email, phone, extra: extraVal });
      }

      sendOrderEmailsOnce_(orderId, "MANUAL_PENDING");

      return ok_({
        found: true,
        orderId,
        fulfillment: "MANUAL_PENDING",
        message: planCfg.postPaymentMessage || "✅ Payment received. Activation will be done manually within a few hours.",
        postPaymentMessage: planCfg.postPaymentMessage || "",   // ✅ ADDED
        subscription: sub
      });
    }

    // -------- Instant fulfillment --------
    let invRes = null;

    const svcLower = String(service || "").toLowerCase();
    const planLower = String(plan || "").toLowerCase();

    if (planCfg.allocationPolicy === "PROFILE" && svcLower.includes("netflix")) {
      invRes = allocateNetflixProfile_(plan, durationDays);
    } else if (planCfg.allocationPolicy === "CAPACITY" && svcLower.includes("prime")) {
      // Prime: requires device type in ExtraFieldValue = TV / NON_TV
      const deviceType = (extraVal || "").toUpperCase();
      if (deviceType !== "TV" && deviceType !== "NON_TV") {
        throw new Error("Prime requires device type: TV or NON_TV (ExtraFieldValue).");
      }
      invRes = allocatePrimeAccountCapacity_(deviceType, durationDays);
    } else if (planCfg.allocationPolicy === "ACCOUNT") {
      invRes = allocateWholeAccount_(service, durationDays);
    } else {
      throw new Error(`Unsupported allocationPolicy: ${planCfg.allocationPolicy}`);
    }

    if (!invRes || !invRes.ok) {
      throw new Error(invRes?.message || "Allocation failed.");
    }

    // Mark order fulfilled
    orders.getRange(rowNum, idx["FulfillmentStatus"] + 1).setValue(FULFILL_STATUS.FULFILLED);
    if (idx["FulfilledAt"] != null) orders.getRange(rowNum, idx["FulfilledAt"] + 1).setValue(now_());
    if (idx["InventoryRef"] != null) orders.getRange(rowNum, idx["InventoryRef"] + 1).setValue(invRes.inventoryRef || "");

    // Create subscription record
    const sub = createSubscriptionRecord_(orderId, service, plan, email, phone, durationDays, planCfg, invRes);

    if (typeof notifyTelegram_ === "function") {
      notifyTelegram_("FULFILLED", { orderId, service, plan, email, phone, inv: invRes.inventoryRef });
    }

    sendOrderEmailsOnce_(orderId, "FULFILLED");

    return ok_({
      found: true,
      orderId,
      fulfillment: "FULFILLED",
      postPaymentMessage: planCfg.postPaymentMessage || "",   // ✅ ADDED
      access: invRes.access || {},
      inventoryRef: invRes.inventoryRef || "",
      subscription: sub,
      message: "✅ Payment verified and access granted."
    });

  } catch (e) {
    // record error on order
    try {
      const orders = sh_(TAB_ORDERS);
      const rn = getRowByValue_(orders, "OrderID", orderId);
      if (rn) {
        const { idx } = headerIndex_(orders);
        if (idx["FulfillmentStatus"] != null) orders.getRange(rn, idx["FulfillmentStatus"] + 1).setValue(FULFILL_STATUS.FAILED);
        if (idx["Error"] != null) orders.getRange(rn, idx["Error"] + 1).setValue(String(e));
      }
    } catch (_) {}

    return bad_("Fulfillment failed: " + e);

  } finally {
    lock.releaseLock();
  }
}


// ---------- Plan config loader ----------
function getPlanCfg_(service, plan) {
  const plans = sh_(TAB_PLANS);
  const { idx } = headerIndex_(plans);
  const last = plans.getLastRow();
  if (last < 2) return null;
  const data = plans.getRange(2, 1, last - 1, plans.getLastColumn()).getValues();

  for (const r of data) {
    if (String(r[idx["Service"]] || "").trim() === service && String(r[idx["Plan"]] || "").trim() === plan) {
      const active = String(r[idx["IsActive"]] || "").trim().toUpperCase() === "TRUE";
      if (!active) return null;
      return {
        fulfillmentMode: String(r[idx["FulfillmentMode"]] || "").trim().toUpperCase(),
        allocationPolicy: String(r[idx["AllocationPolicy"]] || "").trim().toUpperCase(),
        postPaymentMessage: String(r[idx["PostPaymentMessage"]] || "").trim()
      };
    }
  }
  return null;
}


// ---------- Email sender (IDEMPOTENT) ----------
function sendOrderEmailsOnce_(orderId, mode) {
  try {
    if (typeof sendOrderEmails_ !== "function") return;

    const subs = sh_(TAB_SUBS);
    const rn = getRowByValue_(subs, "OrderID", orderId);

    if (!rn) {
      sendOrderEmails_(orderId, mode);
      return;
    }

    const { idx } = headerIndex_(subs);
    const sentCol = idx["LastAccessSentAt"];

    if (sentCol == null) {
      sendOrderEmails_(orderId, mode);
      return;
    }

    const already = subs.getRange(rn, sentCol + 1).getValue();
    if (already) return;

    sendOrderEmails_(orderId, mode);
    subs.getRange(rn, sentCol + 1).setValue(now_());
  } catch (e) {}
}


// ---------- Subscription writer ----------
function createSubscriptionRecord_(orderId, service, plan, email, phone, durationDays, planCfg, invRes) {
  const subs = sh_(TAB_SUBS);
  const subId = genSubId_();
    // ✅ If Netflix PRIVATE_ROTATING marked profile with placeholder, replace it with the real SubID
  try {
    if (invRes && invRes.inventoryRef && String(invRes.inventoryRef).indexOf("#P") > -1) {
      const invProf = sh_(TAB_INV_PROFILES);
      const { idx: pIdx } = headerIndex_(invProf);

      if (pIdx["AccountID"] != null && pIdx["ProfileNumber"] != null && pIdx["CurrentSubID"] != null) {
        const parts = String(invRes.inventoryRef).split("#P");
        const accId = parts[0];
        const pNo = Number(parts[1]);

        const last = invProf.getLastRow();
        if (last >= 2) {
          const data = invProf.getRange(2, 1, last - 1, invProf.getLastColumn()).getValues();
          for (let i = 0; i < data.length; i++) {
            const r = data[i];
            if (String(r[pIdx["AccountID"]] || "").trim() === accId && Number(r[pIdx["ProfileNumber"]]) === pNo) {
              const cur = String(r[pIdx["CurrentSubID"]] || "").trim();
              if (cur === "PENDING_SUB_ID" || cur === "") {
                invProf.getRange(i + 2, pIdx["CurrentSubID"] + 1).setValue(subId);
              }
              break;
            }
          }
        }
      }
    }
  } catch (e) {}

  const start = now_();
  const expiry = addDays_(start, durationDays || 30);
  const cooldownDays = asNumber_(getSetting_("REUSE_COOLDOWN_DAYS", 10));
  const releaseEligibleAt = addDays_(expiry, cooldownDays);

  const access = invRes.access || {};
  const deviceType = invRes.deviceType || "";
  const deviceConcurrency = invRes.deviceConcurrency || "";

  subs.appendRow([
    subId,
    orderId,
    phone,
    email,
    service,
    plan,
    start,
    expiry,
    SUB_STATUS.ACTIVE,
    planCfg.fulfillmentMode,
    planCfg.allocationPolicy,
    invRes.inventoryRef || "",
    deviceType,
    deviceConcurrency,
    access.user || "",
    access.pass || "",
    access.profileNumber || "",
    access.profileName || "",
    access.profilePin || "",
    "", // Notes
    "", // LastAccessSentAt
    releaseEligibleAt,
    "", "", "" // AdminStatusOverride, AdminNote, AdminUpdatedAt
  ]);

  return { subId, start, expiry, status: SUB_STATUS.ACTIVE };
}


// ---------- Helper: return access from SUBSCRIPTIONS by OrderID ----------
function getAccessFromSubsByOrderId_(orderId) {
  try {
    const subs = sh_(TAB_SUBS);
    const rn = getRowByValue_(subs, "OrderID", orderId);
    if (!rn) return {};

    const { idx } = headerIndex_(subs);

    function gv(col) {
      if (idx[col] == null) return "";
      return subs.getRange(rn, idx[col] + 1).getValue();
    }

    return {
      user: String(gv("LoginId") || ""),
      pass: String(gv("Password") || ""),
      profileNumber: gv("ProfileNumber") || "",
      profileName: String(gv("ProfileName") || ""),
      profilePin: String(gv("ProfilePIN") || "")
    };
  } catch (e) {
    return {};
  }
}


// ---------- Allocation engines ----------

function allocateNetflixProfile_(plan, durationDays) {
  const planLower = String(plan || "").toLowerCase();
  const isSharing = planLower.includes("sharing") || planLower.includes("group");
  const isPrivate = planLower.includes("private");

  if (isSharing) {
    return allocateNetflixSharingSlot_(durationDays);
  }

  // Default everything non-sharing to private rotating
  return allocateNetflixPrivateProfile_(durationDays);
}

function allocateNetflixSharingSlot_(durationDays) {
  const invAcc = sh_(TAB_INV_ACCOUNTS);
  const invProf = sh_(TAB_INV_PROFILES);
  const cap = sh_(TAB_INV_CAPACITY);
  const subs = sh_(TAB_SUBS);

  const { idx: aIdx } = headerIndex_(invAcc);
  const { idx: pIdx } = headerIndex_(invProf);
  const { idx: cIdx } = headerIndex_(cap);
  const { idx: sIdx } = headerIndex_(subs);

  const sharingProfileNoSetting = asNumber_(getSetting_("NETFLIX_SHARING_PROFILE_NO", 1));
  const maxTotalDefault = asNumber_(getSetting_("NETFLIX_SHARING_MAX_TOTAL", 4));

  // Read accounts
  const aLast = invAcc.getLastRow();
  if (aLast < 2) return bad_("No inventory accounts.");
  const aData = invAcc.getRange(2, 1, aLast - 1, invAcc.getLastColumn()).getValues();

  const netflixAccounts = aData
    .map((r, i) => ({ r, rowNum: i + 2 }))
    .filter(o => String(o.r[aIdx["Service"]] || "").trim().toLowerCase().includes("netflix"))
    .filter(o => String(o.r[aIdx["IsActive"]] || "").trim().toUpperCase() === "TRUE");

  if (!netflixAccounts.length) return bad_("No active Netflix accounts.");

  // Read profiles
  const pLast = invProf.getLastRow();
  const pData = pLast < 2 ? [] : invProf.getRange(2, 1, pLast - 1, invProf.getLastColumn()).getValues();

  // Read capacity map (optional)
  const capMap = new Map();
  const cLast = cap.getLastRow();
  if (cLast >= 2) {
    const cData = cap.getRange(2, 1, cLast - 1, cap.getLastColumn()).getValues();
    cData.forEach(r => {
      const svc = String(r[cIdx["Service"]] || "").trim().toLowerCase();
      if (!svc.includes("netflix")) return;
      const accountId = String(r[cIdx["AccountID"]] || "").trim();
      const isActive = String(r[cIdx["IsActive"]] || "").trim().toUpperCase() === "TRUE";
      const maxTotal = asNumber_(r[cIdx["MaxTotal"]] || maxTotalDefault);
      if (accountId) capMap.set(accountId, { maxTotal, isActive });
    });
  }

  // Subs data for occupancy
  const nowMs = now_().getTime();
  const sLast = subs.getLastRow();
  const sData = sLast < 2 ? [] : subs.getRange(2, 1, sLast - 1, subs.getLastColumn()).getValues();

  function countActiveByInvRef_(invRef) {
    let cnt = 0;
    for (const r of sData) {
      const svc = String(r[sIdx["Service"]] || "").trim().toLowerCase();
      if (!svc.includes("netflix")) continue;

      const ir = String(r[sIdx["InventoryRef"]] || "").trim();
      if (ir !== invRef) continue;

      const rel = r[sIdx["ReleaseEligibleAt"]];
      const relMs = rel instanceof Date ? rel.getTime() : new Date(rel).getTime();
      if (isNaN(relMs)) continue;

      if (nowMs < relMs) cnt++;
    }
    return cnt;
  }

  function findReservedSharingProfile_(accountId) {
    let fallback = null;

    for (let i = 0; i < pData.length; i++) {
      const r = pData[i];
      const acc = String(r[pIdx["AccountID"]] || "").trim();
      if (acc !== accountId) continue;

      const type = String(r[pIdx["ProfileType"]] || "").trim().toUpperCase();
      const isRes = String(r[pIdx["IsReserved"]] || "").trim().toUpperCase() === "TRUE";
      const pNo = asNumber_(r[pIdx["ProfileNumber"]]);

      if (type === "SHARING_RES" || isRes) {
        if (pNo === sharingProfileNoSetting) return { r, rowNum: i + 2 };
        if (!fallback) fallback = { r, rowNum: i + 2 };
      }
    }
    return fallback;
  }

  for (const accObj of netflixAccounts) {
    const accountId = String(accObj.r[aIdx["AccountID"]] || "").trim();
    const loginId = String(accObj.r[aIdx["LoginId"]] || "").trim();
    const pass = String(accObj.r[aIdx["Password"]] || "").trim();
    if (!accountId || !loginId || !pass) continue;

    const capCfg = capMap.get(accountId) || { maxTotal: maxTotalDefault, isActive: true };
    if (!capCfg.isActive) continue;

    const prof = findReservedSharingProfile_(accountId);
    if (!prof) continue;

    const pNo = asNumber_(prof.r[pIdx["ProfileNumber"]]);
    if (!pNo) continue;

    const inventoryRef = `${accountId}#P${pNo}`;
    const used = countActiveByInvRef_(inventoryRef);

    if (used >= capCfg.maxTotal) continue;

    const profileName = String(prof.r[pIdx["ProfileDisplayName"]] || "").trim() || "FluxFilm";
    const profilePin = String(prof.r[pIdx["ProfilePIN"]] || "").trim();

    return ok_({
      inventoryRef,
      access: {
        user: loginId,
        pass: pass,
        profileNumber: pNo,
        profileName: profileName,
        profilePin: profilePin
      }
    });
  }

  return bad_("No Netflix sharing slots available right now.");
}

function allocateNetflixPrivateProfile_(durationDays) {
  const invAcc = sh_(TAB_INV_ACCOUNTS);
  const invProf = sh_(TAB_INV_PROFILES);

  const { idx: aIdx } = headerIndex_(invAcc);
  const { idx: pIdx } = headerIndex_(invProf);

  const sharingProfileNo = asNumber_(getSetting_("NETFLIX_SHARING_PROFILE_NO", 1));
  const cooldownDays = asNumber_(getSetting_("REUSE_COOLDOWN_DAYS", 10));

  const aLast = invAcc.getLastRow();
  if (aLast < 2) return bad_("No inventory accounts.");
  const aData = invAcc.getRange(2, 1, aLast - 1, invAcc.getLastColumn()).getValues();

  const netflixAccounts = aData
    .map((r, i) => ({ r, rowNum: i + 2 }))
    .filter(o => String(o.r[aIdx["Service"]] || "").trim().toLowerCase().includes("netflix"))
    .filter(o => String(o.r[aIdx["IsActive"]] || "").trim().toUpperCase() === "TRUE");

  if (!netflixAccounts.length) return bad_("No active Netflix accounts.");

  const pLast = invProf.getLastRow();
  const pData = pLast < 2 ? [] : invProf.getRange(2, 1, pLast - 1, invProf.getLastColumn()).getValues();
  const nowMs = now_().getTime();

  function pickPrivateProfile_(accountId) {
    let best = null;

    for (let i = 0; i < pData.length; i++) {
      const r = pData[i];
      if (String(r[pIdx["AccountID"]] || "").trim() !== accountId) continue;

      const pNo = asNumber_(r[pIdx["ProfileNumber"]]);
      if (pNo === sharingProfileNo) continue;

      const type = String(r[pIdx["ProfileType"]] || "").trim().toUpperCase();
      if (type !== "PRIVATE_ROTATING") continue;

      const statusRaw = String(r[pIdx["Status"]] || "").trim().toUpperCase();
      const status = statusRaw || "FREE";
      const curSub = String(r[pIdx["CurrentSubID"]] || "").trim();

      if (status === "ASSIGNED" && !curSub) {
        return { r, rowNum: i + 2 };
      }

      if (status === "FREE") {
        return { r, rowNum: i + 2 };
      }

      const rel = r[pIdx["ReleaseEligibleAt"]];
      const relMs = rel instanceof Date ? rel.getTime() : new Date(rel).getTime();
      if ((status === "COOLDOWN" || status === "ASSIGNED") && !isNaN(relMs) && nowMs >= relMs) {
        best = { r, rowNum: i + 2 };
      }
    }
    return best;
  }

  for (const accObj of netflixAccounts) {
    const accountId = String(accObj.r[aIdx["AccountID"]] || "").trim();
    const loginId = String(accObj.r[aIdx["LoginId"]] || "").trim();
    const pass = String(accObj.r[aIdx["Password"]] || "").trim();
    if (!accountId || !loginId || !pass) continue;

    const prof = pickPrivateProfile_(accountId);
    if (!prof) continue;

    const pNo = asNumber_(prof.r[pIdx["ProfileNumber"]]);
    const profileName = String(prof.r[pIdx["ProfileDisplayName"]] || "").trim() || "Private";
    const profilePin = String(prof.r[pIdx["ProfilePIN"]] || "").trim();

    const expiry = addDays_(now_(), durationDays || 30);
    const release = addDays_(expiry, cooldownDays);

    if (pIdx["Status"] != null) invProf.getRange(prof.rowNum, pIdx["Status"] + 1).setValue("ASSIGNED");
    if (pIdx["CurrentSubID"] != null) invProf.getRange(prof.rowNum, pIdx["CurrentSubID"] + 1).setValue("PENDING_SUB_ID");
    if (pIdx["AssignedAt"] != null) invProf.getRange(prof.rowNum, pIdx["AssignedAt"] + 1).setValue(now_());
    if (pIdx["ExpiryDate"] != null) invProf.getRange(prof.rowNum, pIdx["ExpiryDate"] + 1).setValue(expiry);
    if (pIdx["ReleaseEligibleAt"] != null) invProf.getRange(prof.rowNum, pIdx["ReleaseEligibleAt"] + 1).setValue(release);

    const inventoryRef = `${accountId}#P${pNo}`;

    return ok_({
      inventoryRef,
      access: {
        user: loginId,
        pass: pass,
        profileNumber: pNo,
        profileName: profileName,
        profilePin: profilePin
      }
    });
  }

  return bad_("No Netflix private profiles available right now.");
}

// Prime: CAPACITY allocation (Total<=4, TV<=2) using SUBSCRIPTIONS + ReleaseEligibleAt
function allocatePrimeAccountCapacity_(deviceType, durationDays) {
  const invAcc = sh_(TAB_INV_ACCOUNTS);
  const cap = sh_(TAB_INV_CAPACITY);
  const subs = sh_(TAB_SUBS);

  const { idx: aIdx } = headerIndex_(invAcc);
  const { idx: cIdx } = headerIndex_(cap);
  const { idx: sIdx } = headerIndex_(subs);

  const maxTotalDefault = asNumber_(getSetting_("PRIME_MAX_TOTAL", 4));
  const maxTVDefault = asNumber_(getSetting_("PRIME_MAX_TV", 2));

  const aLast = invAcc.getLastRow();
  if (aLast < 2) return bad_("No inventory accounts.");
  const aData = invAcc.getRange(2, 1, aLast - 1, invAcc.getLastColumn()).getValues();

  const primeAccounts = aData
    .map((r, i) => ({ r, rowNum: i + 2 }))
    .filter(o => String(o.r[aIdx["Service"]] || "").trim().toLowerCase().includes("prime"))
    .filter(o => String(o.r[aIdx["IsActive"]] || "").trim().toUpperCase() === "TRUE");

  if (!primeAccounts.length) return bad_("No active Prime accounts.");

  const capMap = new Map();
  const cLast = cap.getLastRow();
  if (cLast >= 2) {
    const cData = cap.getRange(2, 1, cLast - 1, cap.getLastColumn()).getValues();
    cData.forEach(r => {
      const service = String(r[cIdx["Service"]] || "").trim().toLowerCase();
      if (!service.includes("prime")) return;
      const accountId = String(r[cIdx["AccountID"]] || "").trim();
      const isActive = String(r[cIdx["IsActive"]] || "").trim().toUpperCase() === "TRUE";
      const maxTotal = asNumber_(r[cIdx["MaxTotal"]] || maxTotalDefault);
      const maxTV = asNumber_(r[cIdx["MaxTV"]] || maxTVDefault);
      if (accountId) capMap.set(accountId, { maxTotal, maxTV, isActive });
    });
  }

  const nowMs = now_().getTime();
  const sLast = subs.getLastRow();
  const sData = sLast < 2 ? [] : subs.getRange(2, 1, sLast - 1, subs.getLastColumn()).getValues();

  function occupancy(accountId) {
    let total = 0, tv = 0;
    for (const r of sData) {
      const svc = String(r[sIdx["Service"]] || "").trim().toLowerCase();
      if (!svc.includes("prime")) continue;

      const invRef = String(r[sIdx["InventoryRef"]] || "").trim();
      if (invRef !== accountId) continue;

      const release = r[sIdx["ReleaseEligibleAt"]];
      const relMs = release instanceof Date ? release.getTime() : new Date(release).getTime();
      if (isNaN(relMs)) continue;

      if (nowMs < relMs) {
        total++;
        const dt = String(r[sIdx["DeviceType"]] || "").trim().toUpperCase();
        if (dt === "TV") tv++;
      }
    }
    return { total, tv };
  }

  for (const accObj of primeAccounts) {
    const accountId = String(accObj.r[aIdx["AccountID"]] || "").trim();
    const loginId = String(accObj.r[aIdx["LoginId"]] || "").trim();
    const pass = String(accObj.r[aIdx["Password"]] || "").trim();
    if (!accountId || !loginId || !pass) continue;

    const capCfg = capMap.get(accountId) || { maxTotal: maxTotalDefault, maxTV: maxTVDefault, isActive: true };
    if (!capCfg.isActive) continue;

    const occ = occupancy(accountId);
    if (occ.total >= capCfg.maxTotal) continue;
    if (deviceType === "TV" && occ.tv >= capCfg.maxTV) continue;

    return ok_({
      inventoryRef: accountId,
      deviceType,
      deviceConcurrency: "1",
      access: { user: loginId, pass: pass }
    });
  }

  return bad_("Prime slots are full right now (TV/non-TV capacity).");
}

// Account-based: allocate any active account (whole account)
function allocateWholeAccount_(service, durationDays) {
  const invAcc = sh_(TAB_INV_ACCOUNTS);
  const { idx } = headerIndex_(invAcc);

  const last = invAcc.getLastRow();
  if (last < 2) return bad_("No inventory accounts.");
  const data = invAcc.getRange(2, 1, last - 1, invAcc.getLastColumn()).getValues();

  const svcLower = String(service || "").trim().toLowerCase();

  for (let i = 0; i < data.length; i++) {
    const r = data[i];
    const s = String(r[idx["Service"]] || "").trim().toLowerCase();
    const active = String(r[idx["IsActive"]] || "").trim().toUpperCase() === "TRUE";
    if (!active) continue;
    if (!s.includes(svcLower)) continue;

    const accountId = String(r[idx["AccountID"]] || "").trim();
    const loginId = String(r[idx["LoginId"]] || "").trim();
    const pass = String(r[idx["Password"]] || "").trim();
    if (!accountId || !loginId || !pass) continue;

    return ok_({
      inventoryRef: accountId,
      access: { user: loginId, pass: pass }
    });
  }

  return bad_("No accounts available for this service.");
}
